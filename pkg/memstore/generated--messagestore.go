// This file was generated by robots; DO NOT EDIT.
// run: 'make generate' to regenerate this file.

package memstore

import (
	"strconv"
)

// MessageStore stores data in memory by key and value
type MessageStore struct {
	kv *KvStore
}

// All returns all entries.
func (h *MessageStore) All() []Message {
	r := make([]Message, h.Len())

	for i, item := range h.kv.All() {
		if record, ok := item.(Message); ok {
			r[i] = record
		}
	}

	return r
}

// Slice returns entries within the range.
func (h *MessageStore) Slice(low, high int) []Message {
	r := make([]Message, h.Len())

	for i, item := range h.kv.Slice(low, high) {
		if record, ok := item.(Message); ok {
			r[i] = record
		}
	}

	return r
}

// Get a single value.
func (h *MessageStore) Get(ID int) (Message, bool) {
	if record, ok := h.kv.Get(strconv.Itoa(ID)); ok {
		if record, ok := record.(Message); ok {
			return record, true
		}
	}
	return Message{}, false
}

// Put new Message
func (h *MessageStore) Put(ID int, value Message) bool {
	return h.kv.Put(strconv.Itoa(ID), value)
}

// Delete a Message
func (h *MessageStore) Delete(ID int) bool {
	return h.kv.Delete(strconv.Itoa(ID))
}

// Len gets number of entries
func (h *MessageStore) Len() int {
	return h.kv.Len()
}

// FromIndex gets value by index
func (h *MessageStore) FromIndex(i int) (Message, bool) {
	if record, ok := h.kv.FromIndex(i); ok {
		if record, ok := record.(Message); ok {
			return record, true
		}
	}
	return Message{}, false
}

// Sort items in memory
func (h *MessageStore) Sort(less func(i, j int) bool) {
	h.kv.Sort(less)
}

// NewMessageStore returns a new in memory repository for Message records.
func NewMessageStore() *MessageStore {
	return &MessageStore{
		kv: NewKvStore(),
	}
}
