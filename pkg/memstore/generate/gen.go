package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
)

var t = `// This file was generated by robots; DO NOT EDIT.
// run: 'make generate' to regenerate this file.

package {{ .PackageName }};

import (
	"strconv"
)

// {{ .Name }}Store stores data in memory by key and value
type {{ .Name }}Store struct {
	kv *KvStore
}

// All returns all entries.
func (h *{{ .Name }}Store) All() []{{ .Name }} {
	r := make([]{{ .Name }}, h.Len())
	
	for i, item := range h.kv.All() {
		if record, ok := item.({{ .Name }}); ok {
			r[i] = record
		}
	}
	
	return r
}

// Slice returns entries within the range.
func (h *{{ .Name }}Store) Slice(low, high int) []{{ .Name }} {
	r := make([]{{ .Name }}, h.Len())
	
	for i, item := range h.kv.Slice(low, high) {
		if record, ok := item.({{ .Name }}); ok {
			r[i] = record
		}
	}

	return r
}

// Get a single value.
func (h *{{ .Name }}Store) Get(ID int) ({{ .Name }}, bool) {
	if record, ok := h.kv.Get(strconv.Itoa(ID)); ok {
		if record, ok := record.({{ .Name }}); ok {
			return record, true
		} 
	} 
	return {{ .Name }}{}, false
}

// Put new {{ .Name }}
func (h *{{ .Name }}Store) Put(ID int, value {{ .Name }}) bool {
	return h.kv.Put(strconv.Itoa(ID), value)
}

// Delete a {{ .Name }}
func (h *{{ .Name }}Store) Delete(ID int) bool {
	return h.kv.Delete(strconv.Itoa(ID))
}

// Len gets number of entries
func (h *{{ .Name }}Store) Len() int {
	return h.kv.Len()
}

// FromIndex gets value by index
func (h *{{ .Name }}Store) FromIndex(i int) ({{ .Name }}, bool) {
	if record, ok := h.kv.FromIndex(i); ok {
		if record, ok := record.({{ .Name }}); ok {
			return record, true
		} 
	} 
	return {{ .Name }}{}, false
}

// Sort items in memory
func (h *{{ .Name }}Store) Sort(less func(i, j int) bool) {
	h.kv.Sort(less)
}

// New{{ .Name }}Store returns a new in memory repository for {{ .Name }} records.
func New{{ .Name }}Store() *{{ .Name }}Store {
	return &{{ .Name }}Store{
		kv: NewKvStore(),
	}
}
`

var packageTemplate = template.Must(
	template.New("").
		Funcs(template.FuncMap{
			"Title": strings.Title,
		}).
		Parse(t),
)

func main() {
	wordPtr := flag.String("name", "name", "a string")
	fileOut := flag.String("fileOut", fmt.Sprintf("%s.go", *wordPtr), "out file")

	flag.Parse()

	f := strings.Trim(*fileOut, "\"")

	fmt.Println(*wordPtr)
	fmt.Println(f)

	Generate(f, "memstore", *wordPtr)
}

// Generate queries to file
func Generate(fileOut string, packageName string, name string) {
	f, err := os.Create(fileOut)
	die(err)
	defer f.Close()

	var buf bytes.Buffer
	packageTemplate.Execute(&buf, struct {
		PackageName string
		Name        string
	}{
		PackageName: packageName,
		Name:        name,
	})

	p, err := format.Source(buf.Bytes())
	die(err)
	f.Write(p)
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
