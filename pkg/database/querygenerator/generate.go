package querygenerator

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
)

// QueryType type
type QueryType int

const (
	// QueryRow type value
	QueryRow QueryType = iota
	// Query type value
	Query
	// Exec type value
	Exec
)

// FuncArg Describes a function argument
type FuncArg struct {
	Name string
	Type string
}

// GenTask task
type GenTask struct {
	QueryName string
	SQL       string
	FuncName  string
	FuncArgs  []FuncArg
	QueryType QueryType
}

func (q QueryType) String() string {
	switch q {
	case QueryRow:
		return "QueryRow"
	case Query:
		return "Query"
	case Exec:
		return "Exec"
	}

	return ""
}

var t = `// This file was generated by robots; DO NOT EDIT.
// run: 'make generate' to regenerate this file.

package postgres

import (
	"database/sql"
	{{ range .Imports }}
	"{{- . -}}"
	{{ end }}
)
{{ range .Queries }}
// {{ .QueryName }} sql query
var {{ .QueryName }} = ` + "`" + `{{ .SQL }}` + "`" + `
{{ if eq .QueryType.String  "Exec" }}
func {{.FuncName}}(db *sql.DB{{ JoinFuncArgs .FuncArgs -}}) (sql.Result, error) {
	return db.Exec({{ .QueryName }}{{ JoinQueryArgs .FuncArgs -}})
}
{{ end }}
{{ if eq .QueryType.String  "QueryRow" }}
func {{.FuncName}}(db *sql.DB{{ JoinFuncArgs .FuncArgs -}}) *sql.Row  {
	return db.QueryRow({{ .QueryName }}{{ JoinQueryArgs .FuncArgs -}})
}
{{ end }}
{{ if eq .QueryType.String  "Query" }}
func {{.FuncName}}(db *sql.DB{{ JoinFuncArgs .FuncArgs -}}) (*sql.Rows, error) {
	return db.Query({{ .QueryName }}{{ JoinQueryArgs .FuncArgs -}})
}
{{ end }}
{{ end }}
`

// JoinFuncArgs renders list of arguments
func JoinFuncArgs(attrs []FuncArg) string {
	if len(attrs) == 0 {
		return ""
	}
	joinedAttrs := []string{}
	for _, a := range attrs {
		joinedAttrs = append(joinedAttrs, fmt.Sprintf("%s %s", a.Name, a.Type))
	}
	return ", " + strings.Join(joinedAttrs, ", ")
}

// JoinQueryArgs nice
func JoinQueryArgs(attrs []FuncArg) string {
	if len(attrs) == 0 {
		return ""
	}
	keys := make([]string, 0, len(attrs))
	for _, k := range attrs {
		keys = append(keys, k.Name)
	}
	return ", " + strings.Join(keys, ", ")
}

var packageTemplate = template.Must(
	template.New("").
		Funcs(template.FuncMap{
			"JoinFuncArgs":  JoinFuncArgs,
			"JoinQueryArgs": JoinQueryArgs,
		}).
		Parse(t),
)

// Generate queries to file
func Generate(fileOut string, imports []string, queries []*GenTask) {
	f, err := os.Create(fileOut)
	die(err)
	defer f.Close()

	var buf bytes.Buffer
	packageTemplate.Execute(&buf, struct {
		Imports []string
		Queries []*GenTask
	}{
		Imports: imports,
		Queries: queries,
	})

	p, err := format.Source(buf.Bytes())

	die(err)
	f.Write(p)
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
