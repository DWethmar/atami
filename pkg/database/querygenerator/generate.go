package querygenerator

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
)

// QueryType type
type QueryType int

const (
	// QueryRow type value
	QueryRow QueryType = iota
	// Query type value
	Query
	// Exec type value
	Exec
)

func (q QueryType) String() string {
	switch q {
	case QueryRow:
		return "QueryRow"
	case Query:
		return "Query"
	case Exec:
		return "Exec"
	}

	return ""
}

// FuncArg Describes a function argument
type FuncArg struct {
	Name string
	Type string
}

// GenerateQuery describes what is needed to generate a query function
type GenerateQuery struct {
	Name       string
	SQL        string
	FuncArgs   []FuncArg
	QueryType  QueryType
	MapFunc    string
	ReturnType string
}

var t = `// This file was generated by robots; DO NOT EDIT.
// run: 'make generate' to regenerate this file.

package {{ .PackageName }};

import (
	"database/sql"
	{{ range .Imports }}
	"{{ . }}"
	{{ end }}
)

// Row needs to be implemented in the the map function.
type Row interface {
	Scan(dest ...interface{}) error
	Err() error 
}

{{ range .Queries }}
// {{ .Name }} sql query
var {{ .Name }} = ` + "`" + `{{ .SQL }}` + "`" + `
{{ if eq .QueryType.String  "Exec" }}
func exec{{.Name | Title}}(
	db *sql.DB,
	{{ JoinFuncArgs .FuncArgs -}}
) (sql.Result, error) {
	return db.Exec(
		{{ .Name }},
		{{ JoinQueryArgs .FuncArgs }}
	)
}
{{ end }}
{{ if eq .QueryType.String  "QueryRow" }}
func map{{.Name | Title}}(row Row) ({{.ReturnType}}, error) {
	return {{.MapFunc}}(row)
}

func queryRow{{.Name | Title}}(
	db *sql.DB,
	{{ JoinFuncArgs .FuncArgs -}}
) ({{.ReturnType}}, error)  {
	return map{{.Name | Title}}(db.QueryRow(
		{{ .Name }},
		{{ JoinQueryArgs .FuncArgs }}
	))
}
{{ end }}
{{ if eq .QueryType.String  "Query" }}
func map{{.Name | Title}}(row Row) ({{.ReturnType}}, error) {
	return {{.MapFunc}}(row)
}

func query{{.Name | Title}}(
	db *sql.DB,
	{{ JoinFuncArgs .FuncArgs -}}
) ([]{{.ReturnType}}, error) {
	rows, err :=  db.Query(
		{{ .Name }},
		{{ JoinQueryArgs .FuncArgs }}
	)
	defer rows.Close()
	if err != nil {
		return nil, err
	}
	entries := make([]{{ .ReturnType }}, 0)
	for rows.Next() {
		if entry, err := map{{.Name | Title}}(rows); err == nil {
			entries = append(entries, entry)
		} else {
			return nil, err
		}
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}
	return entries, nil
}
{{ end }}
{{ end }}
`

// JoinFuncArgs renders list of arguments
func JoinFuncArgs(attrs []FuncArg) string {
	if len(attrs) == 0 {
		return ""
	}
	joinedAttrs := []string{}
	for _, a := range attrs {
		joinedAttrs = append(joinedAttrs, fmt.Sprintf("%s %s", a.Name, a.Type))
	}
	return strings.Join(joinedAttrs, ",\n") + ",\n"
}

// JoinQueryArgs nice
func JoinQueryArgs(attrs []FuncArg) string {
	if len(attrs) == 0 {
		return ""
	}
	keys := make([]string, 0, len(attrs))
	for _, k := range attrs {
		keys = append(keys, k.Name)
	}
	return strings.Join(keys, ",\n") + ",\n"
}

var packageTemplate = template.Must(
	template.New("").
		Funcs(template.FuncMap{
			"JoinFuncArgs":  JoinFuncArgs,
			"JoinQueryArgs": JoinQueryArgs,
			"Title":         strings.Title,
		}).
		Parse(t),
)

// Generate queries to file
func Generate(fileOut string, packageName string, imports []string, queries []*GenerateQuery) {
	f, err := os.Create(fileOut)
	die(err)
	defer f.Close()

	var buf bytes.Buffer
	packageTemplate.Execute(&buf, struct {
		PackageName string
		Imports     []string
		Queries     []*GenerateQuery
	}{
		PackageName: packageName,
		Imports:     imports,
		Queries:     queries,
	})

	p, err := format.Source(buf.Bytes())
	die(err)
	f.Write(p)
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
